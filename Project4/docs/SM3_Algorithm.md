# SM3 哈希算法详细说明

## 概述

SM3是中国国家密码管理局发布的密码哈希算法，采用256位输出长度。该算法基于Merkle-Damgård结构，具有抗碰撞性和抗长度扩展攻击的特性。

## 算法结构

### 1. 消息填充

SM3使用以下填充规则：
- 在消息末尾添加一个1位
- 添加k个0位，使得消息长度（以位为单位）+ 1 + k ≡ 448 (mod 512)
- 添加64位的消息长度（以位为单位）

### 2. 消息扩展

将512位的消息块扩展为132个字（W0到W131）：

**前16个字（W0-W15）：**
```
W[i] = M[i]  (0 ≤ i ≤ 15)
```

**后16个字（W16-W67）：**
```
W[i] = P1(W[i-16] ⊕ W[i-9] ⊕ (W[i-3] <<< 15)) ⊕ (W[i-13] <<< 7) ⊕ W[i-6]
```

**最后64个字（W68-W131）：**
```
W[i] = W[i-4] ⊕ W[i-9] ⊕ W[i-14] ⊕ W[i-16]
```

其中P1函数定义为：
```
P1(X) = X ⊕ (X <<< 9) ⊕ (X <<< 17)
```

### 3. 压缩函数

压缩函数使用8个32位寄存器（A, B, C, D, E, F, G, H）：

**初始值：**
```
A = 0x7380166F
B = 0x4914B2B9
C = 0x172442D7
D = 0xDA8A0600
E = 0xA96F30BC
F = 0x163138AA
G = 0xE38DEE4D
H = 0xB0FB0E4E
```

**64轮迭代：**
```
FOR i = 0 TO 63:
    SS1 = ((A <<< 12) + E + (T[i] <<< i)) <<< 7
    SS2 = SS1 ⊕ (A <<< 12)
    TT1 = FF[i](A, B, C) + D + SS2 + W'[i]
    TT2 = GG[i](E, F, G) + H + SS1 + W[i]
    D = C
    C = B <<< 9
    B = A
    A = TT1
    H = G
    G = F <<< 19
    F = E
    E = P0(TT2)
```

其中：
- T[i]是常量表
- W'[i]是扩展消息的另一个序列
- FF[i]和GG[i]是布尔函数
- P0是置换函数

### 4. 布尔函数

**FF函数（前16轮）：**
```
FF[i](X, Y, Z) = X ⊕ Y ⊕ Z
```

**FF函数（后48轮）：**
```
FF[i](X, Y, Z) = (X & Y) | (X & Z) | (Y & Z)
```

**GG函数（前16轮）：**
```
GG[i](X, Y, Z) = X ⊕ Y ⊕ Z
```

**GG函数（后48轮）：**
```
GG[i](X, Y, Z) = (X & Y) | (~X & Z)
```

### 5. 置换函数

**P0函数：**
```
P0(X) = X ⊕ (X <<< 9) ⊕ (X <<< 17)
```

**P1函数：**
```
P1(X) = X ⊕ (X <<< 15) ⊕ (X <<< 23)
```

## 实现细节

### 常量表

SM3使用两个常量表：

**T常量（前16轮）：**
```
T[0] = 0x79CC4519
T[1] = 0xF3988A32
T[2] = 0xE7311465
T[3] = 0xCE6228CB
T[4] = 0x9CC45197
T[5] = 0x3988A32F
T[6] = 0x7311465E
T[7] = 0xE6228CBC
T[8] = 0xCC451979
T[9] = 0x988A32F3
T[10] = 0x311465E7
T[11] = 0x6228CBCE
T[12] = 0xC451979C
T[13] = 0x88A32F39
T[14] = 0x11465E73
T[15] = 0x228CBCE6
```

**T常量（后48轮）：**
```
T[i] = 0x7A879D8A  (16 ≤ i ≤ 63)
```

### 消息扩展细节

**W'序列计算：**
```
W'[i] = W[i] ⊕ W[i+4]  (0 ≤ i ≤ 63)
```

## 安全性分析

### 1. 抗碰撞性

SM3设计为抗碰撞攻击，需要约2^128次操作才能找到碰撞。

### 2. 抗长度扩展攻击

虽然SM3基于Merkle-Damgård结构，但通过特殊的填充和压缩函数设计，增强了抗长度扩展攻击的能力。

### 3. 抗差分攻击

SM3的压缩函数设计考虑了差分攻击，通过复杂的布尔函数和置换函数提供保护。

## 性能优化

### 1. 查找表优化

预计算常用的置换函数结果：
```c
static uint32_t P0_TABLE[256];
static uint32_t P1_TABLE[256];

void init_lookup_tables() {
    for (int i = 0; i < 256; i++) {
        P0_TABLE[i] = P0(i);
        P1_TABLE[i] = P1(i);
    }
}
```

### 2. 循环展开

展开压缩函数的循环以减少分支预测开销：
```c
// 展开前16轮
for (int i = 0; i < 16; i++) {
    // 展开的代码
}
```

### 3. SIMD优化

利用现代CPU的向量指令并行处理多个数据块：
```c
// AVX2实现示例
__m256i process_block_avx2(__m256i data) {
    // SIMD优化的压缩函数
}
```

## 测试向量

### 标准测试向量

| 消息 | 哈希值 |
|------|--------|
| "" | 1ab21d8355cfa17f8e6119483c47424a83c63f93189d909dd812a0e2ae2817b |
| "a" | 623476ac18f65d290161e318e87e393817f44f4a623d2a75f7188e8b30809c4 |
| "abc" | 66c7f0f462eeedd9d1f2d46bdc10e4e24167c4875cf2f7a2297da02b8f4ba8e0 |

### 长消息测试

| 消息长度 | 哈希值 |
|----------|--------|
| 1000字节 | 待补充 |
| 10000字节 | 待补充 |

## 实现注意事项

### 1. 字节序

SM3使用小端序（little-endian）表示多字节整数。

### 2. 内存对齐

为了获得最佳性能，建议将数据对齐到32位边界。

### 3. 错误处理

实现应该包含适当的错误检查：
- 空指针检查
- 缓冲区溢出检查
- 输入长度验证

### 4. 线程安全

如果需要在多线程环境中使用，确保实现是线程安全的。

## 参考实现

完整的参考实现可以在以下文件中找到：
- `sm3_basic.c` - 基本实现
- `sm3_optimized.c` - 优化实现
- `sm3_simd.c` - SIMD优化实现

## 参考文献

1. SM3密码哈希算法标准
2. 密码学哈希函数设计原理
3. 性能优化技术研究
4. SIMD编程最佳实践 